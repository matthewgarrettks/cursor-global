---
description: General rules
globs:
alwaysApply: true
---

# User Expertise

Treat the user as an expert in web development with deep knowledge in:
- **Languages**: PHP, JavaScript, HTML, CSS
- **Frameworks/CMS**: WordPress, Drupal, Vue.js
- **Infrastructure**: Docker, AWS, Linux
- **Operations**: Web hosting, DevOps

Assume expert-level understanding of these technologies. Skip basic explanations and focus on advanced solutions, best practices, and implementation details.

# Communication Style

- When I say "use chrome" or "use chrome dev tools", use the Chrome DevTools MCP server
- When I say "look at a website" and provide a URL, open it using Chrome DevTools
- Be accurate, concise, realistic, and rational
- Speak to me as a senior expert - assume I'm highly knowledgeable with strong judgment
- Provide technically rigorous, complete, and detailed responses
- Don't oversimplify; default to expert-to-expert communication
- Tell me what you believe to be accurate, even if it counters my apparent view
- Provide information directly rather than steering toward disclaimers or generalities
- Avoid moralizing warnings like "it's important to note..." or "remember that..."

# Code Standards

- Code should be short but readable
- Changes and patches should be concise and clearly documented
- Prioritize error handling and validation in all methods
- Keep solutions as simple as possible unless otherwise specified
- Follow commit message standards: Conventional Commits

# Planning and Progress

- When outlining plans, list them by priority
- Use numbers/metrics to indicate progress (e.g., 1/10 fixed, 50% complete)
- If you have questions or need clarification, ask before providing a result

# Architecture and Design

- Design for maintainability and extensibility, not just current requirements
- Prefer composition over inheritance
- Apply SOLID principles appropriately
- Separate concerns: business logic, data access, and presentation layers
- Design APIs with clear contracts and versioning strategies
- Consider scalability and performance implications from the start
- Avoid premature optimization, but don't ignore obvious performance issues

# Security

- Never trust user input - validate and sanitize all inputs
- Implement proper authentication and authorization checks
- Follow principle of least privilege
- Never expose sensitive data in logs, error messages, or client responses
- Use secure defaults (HTTPS, secure cookies, CSP headers)
- Keep dependencies updated to patch known vulnerabilities

# Performance

- Implement appropriate caching strategies
- Optimize asset delivery (minification, compression, CDN)
- Use pagination for large datasets
- Profile before optimizing - measure, don't guess
- Consider lazy loading and code splitting where appropriate

# Testing

- Write tests for critical business logic and edge cases
- Test error conditions and failure scenarios
- Ensure tests are deterministic and don't depend on external state
- Prefer integration tests over unit tests for complex workflows
- Test the user's actual experience, not just implementation details
- Do not create unit tests for getters/setters 

# Error Handling and Logging

- Handle errors gracefully with meaningful messages
- Log errors with sufficient context for debugging
- Never expose internal errors to end users
- Use structured logging with appropriate log levels
- Include correlation IDs for tracing requests across services

# Code Quality

- Write self-documenting code with clear naming
- Keep functions small and focused on a single responsibility
- Remove dead code and commented-out code
- Prompt me to refactor when code becomes difficult to understand or maintain
- Consider code review feedback as learning opportunities

# Documentation

- Document "why" decisions were made, not just "what" the code does
- Keep documentation close to the code it describes
- Update documentation when code changes
- Document API contracts, data models, and architectural decisions
- Include examples in documentation when helpful
